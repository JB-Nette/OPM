import java.awt.geom.Point2D;
import org.micromanager.display.DisplayWindow;
import org.micromanager.MultiStagePosition;
import org.micromanager.SequenceSettings;
import org.micromanager.api.AcquisitionOptions;
import org.micromanager.data.Coords;
import org.micromanager.data.Datastore;
import org.micromanager.data.Image;
import org.micromanager.data.Metadata;
import org.micromanager.data.Metadata.MetadataBuilder;
import org.micromanager.data.SummaryMetadata;
import org.micromanager.data.SummaryMetadataBuilder;

import mmcorej.*;

import java.awt.geom.Point2D;
import java.lang.System;
import java.lang.Math;
import java.lang.String;
import java.text.SimpleDateFormat;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import ij.gui.GenericDialog;
import ij.ImagePlus;
import ij.ImageStack;
import ij.process.ImageProcessor;
import ij.process.FloatProcessor;

String setTigerCommand(String port,String command,boolean checkbusy) {

	String answer="";
	send_success=false;
	while (!send_success) {
		exception_occured=false;
		try {
			mmc.setSerialPortCommand(port, command, "\r");
		}
		catch (Exception ex) {
			print("1st send error. Wait, then try again.");
			mmc.sleep(100);
			send_success=false;
			exception_occured=true;
		}
		if (!exception_occured) {
			send_success=true;
		}

		send_success=false;
		exception_occured=false;
		try {
			answer = mmc.getSerialPortAnswer(port, "\r\n");
		}
		catch (Exception ex) {
			print("1st receive error. Wait, then try again.");
			mmc.sleep(100);
			send_success=false;
			exception_occured=true;
		}
		if (!exception_occured) {
			send_success=true;
		}
	}

	if (checkbusy) {
		answer="";
		send_success=false;
		
		while (!send_success) {
			exception_occured=false;
			try {
				mmc.setSerialPortCommand(port, "STATUS", "\r");
			}
			catch (Exception ex) {
				print("1st check send. Wait, then try again.");
				mmc.sleep(100);
				send_success=false;
				exception_occured=true;
			}
			if (!exception_occured) {
				send_success=true;
			}
		}

		send_success=false;
		exception_occured=false;
		
		try {
			answer = mmc.getSerialPortAnswer(port, "\r\n");
		}
		catch (Exception ex) {
			print("1st check receive. Wait, then try again.");
			mmc.sleep(100);
			send_success=false;
			exception_occured=true;
		}
		if (!exception_occured) {
			send_success=true;
		}
		
		while (!answer.matches("N")) {
			answer="";
			send_success=false;
			
			while (!send_success) {
				exception_occured=false;
				try {
					mmc.setSerialPortCommand(port, "STATUS", "\r");
				}
				catch (Exception ex) {
					print("Repeat check send. Wait, then try again.");
					mmc.sleep(100);
					send_success=false;
					exception_occured=true;
				}
				if (!exception_occured) {
					send_success=true;
				}
			}

			send_success=false;
			exception_occured=false;

			try {
				answer = mmc.getSerialPortAnswer(port, "\r\n");
			}
			catch (Exception ex) {
				print("Repeat check receive. Wait, then try again.");
				mmc.sleep(100);
				send_success=false;
				exception_occured=true;
			}
			if (!exception_occured) {
				send_success=true;
			}
		}
	}

	return answer;
}

boolean display_acq=false;

// assign the core to mmc variable
mmc = mm.getCore();

// clean up any existing acquisitions
mmc.stopSequenceAcquisition();
mmc.clearCircularBuffer();

// get focus device
z_stage = mmc.getFocusDevice();

//Pull acquisition settings from MDA window
acqSettings = mm.acquisitions().getAcquisitionSettings();
rootDir = acqSettings.root;
rootDirUnique = mm.data().getUniqueSaveDirectory(rootDir);

//Create multipagetiff datatstore
Datastore store = mm.data().createMultipageTIFFDatastore(rootDirUnique,false,true);

//Create a display for the datastore
if (display_acq) {
	DisplayWindow display = mm.displays().createDisplay(store);
	mm.displays().manage(store);
}
//Setup scan

port = "COM15";

float pixel_size = 0.116; 															// (um)
float overlap = 0.1;																	// (%)
float exposure_ms = 50.;															// (ms)
float exposure_s = exposure_ms / 1000.; 										// (s)
float scan_rate = 0.008;															// (mm/s)
float z_nyquist = 0.4 / 1000.;													// (mm)
int images_to_ignore = Math.round(z_nyquist/(exposure_s*scan_rate));	// (# images)
		
mmc.setExposure(exposure_ms);

float start_y = -3.0;														// (mm)
float end_y = +5.0;															// (mm)
float start_x = 8.5;															// (mm)
float end_x = 13.5;															// (mm)
float scan_distance = Math.abs(start_y-end_y);						// (mm)
float tile_step_um = (2020.*pixel_size) * (1-overlap); 		 	// (um)
float tile_step_mm = (2020.*pixel_size) * (1-overlap) * .001; 	// (mm)
float tile_step_asi = (2020.*pixel_size) * (1-overlap) * 10.0; // (.1 um)

int num_cam_fires = Math.round(scan_distance / (scan_rate * exposure_s));
int num_images = Math.round(num_cam_fires/images_to_ignore);
int num_tiles = Math.round((Math.abs(Math.abs(start_x)-Math.abs(end_x))/tile_step_mm));

print("Number of camera acquisitions per scan strip: "+num_cam_fires);
print("Number of stored images per scan strip: "+num_images);
print("Number of strips: "+num_tiles);
print("Total images: "+(num_images*num_tiles));

command = "SPEED X=.5";
answer = setTigerCommand(port,command,false);
print("Changing X speed to fast for initial move.");
mmc.sleep(50);

command = "MOVE X="+start_x*10000;
answer = setTigerCommand(port,command,true);
print("Moved X axis to start position of: "+start_x);
mmc.sleep(50);

command = "SPEED Y=.5";
answer = setTigerCommand(port,command,false);
print(answer);
print("Changing Y speed to fast for initial move.");
mmc.sleep(50);

command = "MOVE Y="+start_y*10000;
answer = setTigerCommand(port,command,true);
print(answer);
print("Moved Y axis to: "+start_y);
mmc.sleep(50);

command = "SPEED Y="+scan_rate;
answer = setTigerCommand(port,command,false);
print(answer);
print("Setting Y speed to slow scan speed.");
mmc.sleep(50);

command = "1SCAN X? Y=1 Z=9 F=0";
answer = setTigerCommand(port,command,false);
print("Setting up scan axes");
mmc.sleep(50);

command = "1SCANR X="+start_y+" Y="+end_y+" R=50";
answer = setTigerCommand(port,command,false);
print(answer);
print("Setting up slow scan range.");
mmc.sleep(50);

//Create Coordinates builder object
Coords.CoordsBuilder builder = mm.data().getCoordsBuilder();

int x_counter=0;
int stage_pos=0;

while (x_counter < num_tiles) {

	int y_counter=0;
	int image_counter=0;
	int total_counter=0;
	
	command = "1SCAN";
	answer = setTigerCommand(port,command,false);
	print(answer);
	print("Running slow scan... ");

	// start acquisition sequence with camera in internal mode for fastest acquisition
	mmc.startSequenceAcquisition(num_cam_fires, 0, true);
	
	// execute acquisition until no more images are left in the buffer
	while (mmc.getRemainingImageCount() > 0 || mmc.isSequenceRunning(mmc.getCameraDevice())) {
		// if there are images in the buffer, grab and process
		if (mmc.getRemainingImageCount() > 0) {
			// convert top image in buffer to imageProcessor
			TaggedImage tagged = mmc.popNextTaggedImage();
			Image image = mm.data().convertTaggedImage(tagged);

			//if (image_counter==0) {
	
				Point2D.Double point = mmc.getXYStagePosition();
				xNow = point.getX();
				yNow = point.getY();
				zNow = mmc.getPosition(z_stage);
				
				//Create metadata object for image
				MetadataBuilder mdb = image.getMetadata().copy();
				md = mdb.positionName("Pos_"+x_counter+"_"+y_counter).xPositionUm(xNow).yPositionUm(yNow).zPositionUm(zNow).build();
					
				//Build datastore coordinates for image
				builder.stagePosition(stage_pos);
				Coords coords = builder.build();
		
				//Create second image with metadata and datastore coordinates
				image_toDataStore = image.copyWith(coords, md);
				
				//Place images into dataStore
				store.putImage(image_toDataStore);
				y_counter++;
				
				stage_pos++;
	
				int test_counter = y_counter%1000;
				if (test_counter==0) {
					//print("Total camera fires:" +total_counter);
					print("At strip "+x_counter+" of "+num_tiles+" total strips. Acquired "+y_counter+" images out of "+num_images+" for this strip so far...");
				}
				//image_counter++;
			//}
			//else {
			//	if (image_counter<(images_to_ignore)) {
			//		image_counter++;
			//	}
			//	else {image_counter=0;}
			//}
			total_counter++;
		}
		// Wait for another image to arrive.
		else {
			mmc.sleep(Math.min(.5 * exposure_ms, 10));
		}
	}

	// clean up acquistion
	mmc.stopSequenceAcquisition();
	mmc.clearCircularBuffer();

	print("Acquried images when loop exited: "+y_counter+" out of total camera fires: "+total_counter);

	if (y_counter == num_images) {
		
		command = "STATUS";
		answer = setTigerCommand(port,command,true);
		print(answer);
		print("Y axis has reset.");
		mmc.sleep(5000);
		
		x_counter++;
	
		command = "MOVREL X="+tile_step_asi;
		answer = setTigerCommand(port,command,true);
		print(answer);
		print("Moved X axis to: "+(start_x+(x_counter*tile_step_mm)));
		mmc.sleep(50);
	
	}
	else {
		print("An error occurred during image scanning...");

		command = "SPEED Y=.5";
		answer = setTigerCommand(port,command,false);
		print(answer);
		print("Changing Y speed to fast.");
		mmc.sleep(50);
		
		command = "MOVE Y="+start_y*10000;
		answer = setTigerCommand(port,command,true);
		print(answer);
		print("Moved Y axis to: "+start_y);
		mmc.sleep(50);
		
		exit;
		break;
	}
}

//Finish writing data to disk
store.freeze();

//Close dataStore object
store.close();	